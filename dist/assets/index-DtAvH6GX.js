var e=Object.defineProperty,t=(t,s,i)=>((t,s,i)=>s in t?e(t,s,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[s]=i)(t,"symbol"!=typeof s?s+"":s,i);import{p as s,P as i}from"./phaser-hyM8z1KO.js";!function(){const e=document.createElement("link").relList;if(!(e&&e.supports&&e.supports("modulepreload"))){for(const e of document.querySelectorAll('link[rel="modulepreload"]'))t(e);new MutationObserver((e=>{for(const s of e)if("childList"===s.type)for(const e of s.addedNodes)"LINK"===e.tagName&&"modulepreload"===e.rel&&t(e)})).observe(document,{childList:!0,subtree:!0})}function t(e){if(e.ep)return;e.ep=!0;const t=function(e){const t={};return e.integrity&&(t.integrity=e.integrity),e.referrerPolicy&&(t.referrerPolicy=e.referrerPolicy),"use-credentials"===e.crossOrigin?t.credentials="include":"anonymous"===e.crossOrigin?t.credentials="omit":t.credentials="same-origin",t}(e);fetch(e.href,t)}}();const r="Preloader",a="MainMenu",n="Game",o="DebugUIScene",l="barrel",h="assets",c="physics",d=1/0,u=1/0,m="waiting_to_start",p="playing",g="game_over",f="level_complete";class y extends s.Scene{constructor(){super("Boot")}preload(){}create(){this.scene.start(r)}}const b=e=>"coin"===e.label,v=e=>"duck"===e.label,x=e=>"finish"===e.label,w=e=>"enemy"===e.label,P=e=>"fallSensor"===e.label;function C(e){return e.label===l}let B=0,D=0;const L=()=>B;let S=0;const I=()=>S;class A{constructor(e,s){t(this,"scene"),t(this,"camera"),this.scene=e,this.camera=this.scene.cameras.main,this.setupCamera(s)}setupBounds(){this.scene.matter.world.setBounds(0,0,1e4,4e3),this.camera.setBounds(0,0,1e4,4e3)}setupCamera(e){this.setupBounds(),this.camera.startFollow(e,!0,.5,.5),this.camera.setLerp(.5,.5),this.camera.setZoom(1.5)}handleZoomIn(){this.scene.tweens.add({targets:this.camera,zoom:2,duration:700,ease:"Power2"})}}function E(e,t,s){Object.entries(s).forEach((([s,i])=>{i.frames<=1?e.create({key:s,frames:[{key:t,frame:`${i.prefix}.png`}],repeat:0}):e.create({key:s,frames:e.generateFrameNames(t,{prefix:i.prefix,start:1,end:i.frames,zeroPad:4,suffix:".png"}),repeat:i.loop,frameRate:i.frameRate})}))}const M=(e,t)=>{Object.entries(t).forEach((([t,s])=>{if(s.nextAnimation){const r=s.nextAnimation;e.on(i.Animations.Events.ANIMATION_COMPLETE,(s=>{s.key===t&&e.play(r)}))}}))},G=e=>{var t;const s=(null==(t=e.label)?void 0:t.toLowerCase())??"";return["platform","crate-big","crate-small"].includes(s)},k="FX_LAND",R={FX_LAND:{prefix:"fx-land/fx-land-",frames:18,loop:0,frameRate:30}};class O extends Phaser.GameObjects.Sprite{constructor(e,t,s){super(e,t,s,h,R[k].prefix+"0001.png"),this.setScale(.3),this.play(k),e.add.existing(this),this.once(Phaser.Animations.Events.ANIMATION_COMPLETE,(()=>{var e;(null==(e=this.anims.currentAnim)?void 0:e.key)===k&&this.destroy(!0)}))}}const F="DUCK_FALL",T="DUCK_IDLE",_="DUCK_RUN",X={DUCK_FALL:{prefix:"player/fall/duck-fall-",frames:10,loop:0,frameRate:30},DUCK_DEAD:{prefix:"player/dead/duck-dead-",frames:10,loop:0,frameRate:30},DUCK_IDLE:{prefix:"player/idle/duck-idle-",frames:10,loop:0,frameRate:30},DUCK_JUMP:{prefix:"player/jump/duck-jump-",frames:12,loop:0,nextAnimation:F,frameRate:30},DUCK_RUN:{prefix:"player/run/duck-run-",frames:14,loop:-1,frameRate:30}};class N extends Phaser.Physics.Matter.Sprite{constructor(e,s,i){const r=e.cache.json.get(c);super(e.matter.world,s,i,h,X[T].prefix+"0001.png",{shape:r["duck-idle"]}),t(this,"cursors"),t(this,"wasd"),t(this,"isGrounded",!1),t(this,"groundContacts",new Set),t(this,"currentAnimKey",""),t(this,"jumpInProgress",!1),t(this,"lastJumpTime",0),t(this,"isAlive",!0),t(this,"isLevelComplete",!1),t(this,"justLanded",!1),t(this,"currentBarrel",null),t(this,"recentlyExitedBarrel",!1),t(this,"isInBarrel",!1),e.matter.world.on("collisionstart",this.handleCollisionStart,this),e.matter.world.on("collisionend",this.handleCollisionEnd,this),this.setFixedRotation(),this.setupControls(),this.playAnimation(T,!0),this.isAlive=!0,this.isInBarrel=!1,this.currentBarrel=null,this.recentlyExitedBarrel=!1,M(this,X),e.add.existing(this)}setupControls(){var e,t;this.scene.sys.game.device.os.desktop?(this.cursors=null==(e=this.scene.input.keyboard)?void 0:e.createCursorKeys(),this.wasd=null==(t=this.scene.input.keyboard)?void 0:t.addKeys("W,A,D")):this.createMobileControls()}createMobileControls(){}update(){var e,t,s,i,r,a,n,o,l,h,c,d,u,m;if(!this.isAlive)return;if(this.isInBarrel&&this.currentBarrel)return void this.handleInBarrelState();if(!this.cursors||!this.wasd)return;const p=(null==(e=this.cursors.left)?void 0:e.isDown)||(null==(t=this.wasd.A)?void 0:t.isDown),g=(null==(s=this.cursors.right)?void 0:s.isDown)||(null==(i=this.wasd.D)?void 0:i.isDown),f=(null==(r=this.cursors.up)?void 0:r.isDown)||(null==(a=this.wasd.W)?void 0:a.isDown);if(!this.isLevelComplete){let e=0;if(p?(e=-3,this.flipX=!0):g&&(e=3,this.flipX=!1),this.recentlyExitedBarrel||this.setVelocityX(e),f&&this.isGrounded&&!this.isInBarrel)return this.setVelocityY(-9),this.jumpInProgress=!0,this.lastJumpTime=this.scene.time.now,this.playAnimation("DUCK_JUMP",!0),void this.once(Phaser.Animations.Events.ANIMATION_COMPLETE,(()=>{this.isGrounded||this.playAnimation(F,!0)}))}if(this.isGrounded){if(this.isGrounded&&!this.jumpInProgress)if(this.justLanded){const e=(null==(o=null==(n=this.cursors)?void 0:n.left)?void 0:o.isDown)||(null==(h=null==(l=this.wasd)?void 0:l.A)?void 0:h.isDown),t=(null==(d=null==(c=this.cursors)?void 0:c.right)?void 0:d.isDown)||(null==(m=null==(u=this.wasd)?void 0:u.D)?void 0:m.isDown);e||t?this.playAnimation(_):this.playAnimation(T,!1),this.justLanded=!1}else this.isLevelComplete?this.playAnimation(T,!1):this.body&&Math.abs(this.body.velocity.x)>.1?this.playAnimation(_):this.playAnimation(T,!1)}else this.jumpInProgress||this.currentAnimKey!==F&&this.scene.time.now-this.lastJumpTime>150&&this.playAnimation(F)}playAnimation(e,t=!1){if(this.currentAnimKey===e){if(!t)return;this.anims.stop()}this.play(e),this.currentAnimKey=e}handleCollisionStart(e){for(const{bodyA:s,bodyB:i}of e.pairs)v(s)&&G(i)?this.groundContacts.add(i):v(i)&&G(s)&&this.groundContacts.add(s);const t=this.isGrounded;this.isGrounded=this.groundContacts.size>0,this.isGrounded&&!t&&(this.jumpInProgress=!1,this.justLanded=!0,new O(this.scene,this.x,this.getBounds().bottom))}handleCollisionEnd(e){for(const{bodyA:t,bodyB:s}of e.pairs)v(t)&&G(s)?this.groundContacts.delete(s):v(s)&&G(t)&&this.groundContacts.delete(t);this.isGrounded=this.groundContacts.size>0}handleInBarrelState(){var e,t,s,i;this.currentBarrel&&(this.setPosition(this.currentBarrel.x,this.currentBarrel.y),this.setVelocity(0,0),((null==(t=null==(e=this.cursors)?void 0:e.up)?void 0:t.isDown)||(null==(i=null==(s=this.wasd)?void 0:s.W)?void 0:i.isDown))&&(this.currentBarrel.launch(),this.exitBarrel()))}enterBarrel(e){!this.isInBarrel&&this.body&&(this.isInBarrel=!0,this.currentBarrel=e,this.isGrounded=!1,this.jumpInProgress=!1,this.setStatic(!0),this.setVisible(!1),this.currentBarrel.enter())}exitBarrel(){if(console.log("[Player] exitBarrel called"),!this.isInBarrel||!this.currentBarrel||!this.body)return;if(this.recentlyExitedBarrel)return;const e=this.currentBarrel.angle;this.isInBarrel=!1,this.currentBarrel=null,this.setStatic(!1),this.setVisible(!0);const t=Phaser.Math.Vector2.RIGHT.clone().rotate(Phaser.Math.DegToRad(e)).scale(12);console.log(`[Player] Barrel Angle: ${e}, Radian: ${Phaser.Math.DegToRad(e).toFixed(3)}`),this.setVelocity(t.x,t.y),this.playAnimation(F,!0),this.recentlyExitedBarrel=!0,this.scene.time.delayedCall(200,(()=>{this.recentlyExitedBarrel=!1,console.log("[Player] Barrel exit cooldown finished.")}))}finishLevel(){this.isLevelComplete=!0,this.setVelocityX(0),this.isInBarrel&&this.exitBarrel()}kill(){this.isAlive=!1,this.isInBarrel&&this.exitBarrel(),this.playAnimation("DUCK_DEAD"),this.setVelocityX(0),this.setVelocityY(0),this.setStatic(!0)}}const j={LEFT:{prefix:"platforms/platform-left.png",frames:1,loop:0,frameRate:0},RIGHT:{prefix:"platforms/platform-right.png",frames:1,loop:0,frameRate:0},MIDDLE:{prefix:"platforms/platform-middle.png",frames:1,loop:0,frameRate:0}};class U extends Phaser.Physics.Matter.Sprite{constructor(e,s,i,r,a){((e,t,s)=>{if(e.textures.exists(s)){const i=e.make.renderTexture({width:26*t,height:24},!1);return i.draw(s,0,0),i}(function(e,t,s){const i=e.make.container({x:0,y:0,add:!1}),r=26*t,a=e.make.image({key:h,frame:j.LEFT.prefix,x:13,y:12,add:!1}),n=e.make.tileSprite({key:h,frame:j.MIDDLE.prefix,x:26*t/2,y:13.5,width:26*(t-2),height:24,add:!1}),o=e.make.image({key:h,frame:j.RIGHT.prefix,x:r-13,y:12,add:!1});i.add([a,n,o]);const l=e.make.renderTexture({width:r,height:24},!1);l.draw(i),l.saveTexture(s),i.destroy()})(e,t,s)})(e,r,a);const n=e.cache.json.get(c).platform,{collisionFilter:o}=n,l={label:"platform",isStatic:n.isStatic,collisionFilter:{category:o.category,group:o.group,mask:o.mask}};super(e.matter.world,s,i,a,void 0,l),t(this,"segmentCount"),this.segmentCount=r,e.add.existing(this)}}const V={FINISH_IDLE:{prefix:"finish/finish-idle/finish-idle",frames:1,loop:0,frameRate:0},FINISH_ACTIVATED:{prefix:"finish/finish-activated/finish-activated-",frames:19,loop:0,nextAnimation:"FINISH_ACTIVE",frameRate:30},FINISH_ACTIVE:{prefix:"finish/finish-active/finish-active-",frames:8,loop:-1,frameRate:30}};class $ extends Phaser.Physics.Matter.Sprite{constructor(e,s,i){const r=e.cache.json.get(c);super(e.matter.world,s,i,h,void 0,{shape:r.finish,isStatic:!0,isSensor:!0}),t(this,"isActivated",!1),this.setOrigin(.3,.5),this.play("FINISH_IDLE"),M(this,V),e.add.existing(this)}activate(){this.isActivated||(this.play("FINISH_ACTIVATED"),this.isActivated=!0)}}const H={BARREL_IDLE:{prefix:"barrel/launch/barrel-launch-0010",frames:1,loop:0,frameRate:0},BARREL_ENTER:{prefix:"barrel/enter/barrel-enter-",frames:19,loop:0,frameRate:30},BARREL_LAUNCH:{prefix:"barrel/launch/barrel-launch-",frames:10,loop:0,frameRate:30}};class z extends Phaser.Physics.Matter.Sprite{constructor(e,s,i){const r=e.cache.json.get(c);super(e.matter.world,s,i,h,void 0,{shape:r[l],isStatic:!0,isSensor:!0}),t(this,"isEntered",!1),this.angle=-90,this.setOrigin(.22,.5),this.play("BARREL_IDLE"),e.add.existing(this)}update(){this.isEntered&&(this.angle+=2)}enter(){this.play("BARREL_ENTER"),this.isEntered=!0}launch(){if(!this.isEntered)return null;this.play("BARREL_LAUNCH"),this.isEntered=!1;const e=Phaser.Math.DegToRad(this.angle);return new Phaser.Math.Vector2(15*Math.cos(e),15*Math.sin(e))}}const K="COIN_IDLE",Y="COIN_COLLECT",W={COIN_IDLE:{prefix:"coin/coin-idle/coin-idle-",frames:23,loop:-1,frameRate:30},COIN_COLLECT:{prefix:"coin/coin-collect/coin-collect-",frames:8,loop:0,frameRate:30}};class J extends Phaser.Physics.Matter.Sprite{constructor(e,t,s){const i=e.cache.json.get(c);super(e.matter.world,t,s,h,W[K].prefix+"0001.png",{shape:i.coin,isStatic:!0,isSensor:!0}),this.play(K),e.add.existing(this)}collect(){this.play(Y),this.scene.matter.world.remove(this),this.once(Phaser.Animations.Events.ANIMATION_COMPLETE,(()=>{var e;(null==(e=this.anims.currentAnim)?void 0:e.key)===Y&&this.destroy(!0)}))}}const Z={ENEMY_IDLE:{prefix:"enemy/enemy.png",frames:10,loop:0,frameRate:0}},Q=class e extends Phaser.Physics.Matter.Sprite{constructor(e,s,i){const r=e.cache.json.get(c);super(e.matter.world,s,i,h,Z.ENEMY_IDLE.prefix,{shape:r.enemy}),t(this,"speed",1.4),t(this,"direction",1),t(this,"platformBounds"),e.add.existing(this),e.matter.world.on("collisionstart",this.handleCollisionStart,this),this.setFixedRotation()}handleGameOver(){this.setVelocity(0,0)}update(){if(!this.platformBounds)return;this.setVelocity(this.speed*this.direction,0);const{left:e,right:t}=this.getBounds(),{left:s,right:i}=this.platformBounds;t>=i&&1===this.direction?this.direction=-1:e<=s&&-1===this.direction&&(this.direction=1)}handleCollisionStart(t){if(this.platformBounds)return;const s=this.body,i=s.id,r=s.parts?s.parts.map((e=>e.id)):[i];r.includes(i)||r.push(i);for(const{bodyA:a,bodyB:n}of t.pairs){let t=null,s=null;if(r.includes(a.id)&&G(n)?(t=a,s=n):r.includes(n.id)&&G(a)&&(t=n,s=a),t&&s){const t=s.id,i=e.platformCache.get(t);if(i)this.platformBounds=i;else{const{min:i,max:r}=s.bounds,a={left:i.x,right:r.x};e.platformCache.set(t,a),this.platformBounds=a}this.scene.matter.world.off("collisionstart",this.handleCollisionStart,this);break}}}};t(Q,"platformCache",new Map);let q=Q;const ee={CRATE_BIG_IDLE:{prefix:"crate/crate-big.png",frames:1,loop:0,frameRate:0}};class te extends Phaser.Physics.Matter.Sprite{constructor(e,t,s){const i=e.cache.json.get(c);super(e.matter.world,t,s,h,ee.CRATE_BIG_IDLE.prefix,{shape:i["crate-big"]}),e.add.existing(this)}}const se={CRATE_SMALL_IDLE:{prefix:"crate/crate-small.png",frames:1,loop:0,frameRate:0}};class ie extends Phaser.Physics.Matter.Sprite{constructor(e,t,s){const i=e.cache.json.get(c);super(e.matter.world,t,s,h,se.CRATE_SMALL_IDLE.prefix,{shape:i["crate-small"]}),e.add.existing(this)}}function re(e,t,s,i){const r=t.getBounds(),a=r.width;let n=0;const o=Math.floor(a/48),l=s.nextInt(0,o+1);if(l>0){const t=(a-48*(l-1))/2,s=r.top-14-5;for(let a=0;a<l;a++){const o=r.left+t+48*a,l=16;if(Math.abs(o-r.centerX)<l)continue;const h=new J(e,o,s);i.push(h),n++}}return n}class ae{constructor(e){t(this,"seed"),this.seed=e}next(){let e=this.seed+=1831565813;return e=Math.imul(e^e>>>15,1|e),e^=e+Math.imul(e^e>>>7,61|e),((e^e>>>14)>>>0)/4294967296}nextInt(e,t){return Math.floor(this.next()*(t-e)+e)}choice(e){return e[this.nextInt(0,e.length)]}}class ne{constructor(e,s){t(this,"scene"),t(this,"levelNumber"),t(this,"prng"),t(this,"platforms",[]),t(this,"coins",[]),t(this,"enemies",[]),t(this,"crates",[]),t(this,"barrels",[]),t(this,"player"),t(this,"levelMinX",0),t(this,"levelMaxX",0),t(this,"levelLowestY",0),t(this,"PLATFORM_DISPLAY_HEIGHT",32),t(this,"bridgeBarrelRanges",[]),this.scene=e,this.levelNumber=s,this.prng=new ae(this.levelNumber)}generateLevel(){const e=ne.calculateLevelGenerationParams(this.levelNumber),t=this.prng.nextInt(e.minPlatforms,e.maxPlatforms+1);let s=180,i=300,r=0,a=null;const n=[];this.platforms=[],this.enemies=[],this.coins=[],this.crates=[],this.barrels=[],this.bridgeBarrelRanges=[],this.createPlayerStart({x:s,y:i});const o=this.prng.nextInt(e.minPlatformLength,e.maxPlatformLength+1),l=this.createPlatform({x:s,y:i},o,0);a=l;for(let c=1;c<t;c++){let o=this.prng.nextInt(e.minPlatformLength,e.maxPlatformLength+1);const{nextX:l,nextY:h,dX:d}=this.calculateNextPlatformPosition({x:s,y:i},o,a,e);let u=!1,m=0,p=0,g=null;if(d>e.maxHorizontalGap&&c<t-1){m=a.getBounds().right+d/2,g={start:m-20,end:m+20};let e=!1;for(const t of this.bridgeBarrelRanges)if(g.start<t.end&&g.end>t.start){e=!0;break}if(e)console.warn(`  Overlap detected for bridge barrel at X=${m.toFixed(0)}. Placing platform instead.`);else{const e=10;p=a.getBounds().top+24+e,p=Math.min(p,1/0),u=!0}}if(u){console.log(`Impossible gap detected (dX=${d.toFixed(0)} > maxJump=${e.maxHorizontalGap}). Placing barrel.`);const t=new z(this.scene,m,p);this.barrels.push(t),this.bridgeBarrelRanges.push(g),s=m+this.prng.nextInt(e.minHorizontalGap,e.maxHorizontalGap+1),console.log(`  Placed barrel at (${m.toFixed(0)}, ${p.toFixed(0)}). Next platform target X: ${s.toFixed(0)}`)}else{const e=this.createPlatform({x:l,y:h},o,c);r+=re(this.scene,e,this.prng,this.coins),n.push(e),a=e,s=l,i=h}}const h=n.filter((e=>e!==a));return function(e,t,s,i,r,a){if(0===t.length)return;const n=(e=>{for(let t=e.length-1;t>0;t--){const i=s.nextInt(0,t+1);[e[t],e[i]]=[e[i],e[t]]}return e})([...t]),o=i.targetEnemies,l=i.targetCrates,h=o+l,c=n.slice(0,Math.min(h,n.length)),d=new Set;let u=0,m=0;for(let p=0;p<c.length&&u<o;p++){if(d.has(p))continue;const t=c[p];if(t.segmentCount>=6){const s=t.getBounds(),i=s.centerX,a=s.top-20-14,n=new q(e,i,a);r.push(n),u++,d.add(p)}}for(let p=0;p<c.length&&m<l;p++){if(d.has(p))continue;const t=c[p].getBounds(),i=t.centerX,r=s.next()<.5,n=r?64:32,o=t.top-n/2,l=r?new te(e,i,o):new ie(e,i,o);a.push(l),m++,d.add(p)}}(this.scene,h,this.prng,e,this.enemies,this.crates),this.createFinishPoint(a),this.calculateOverallBounds(),console.log(`Level generated with ${this.platforms.length} platforms, ${this.enemies.length} enemies, ${this.crates.length} crates, ${this.barrels.length} barrels, ${r} coins.`),D=r,this.player}static calculateLevelGenerationParams(e){const t=10+e,s=15+e,i=.3+Math.min(.3,.02*e),r=.25+Math.min(.2,.01*e),a=.15+Math.min(.1,.01*e),n=(t+s)/2,o=Math.floor(n*i),l=Math.floor(n*r);let h=Math.floor(n*a);h=Math.max(1,h);const c=o+l+h+2,d=Math.max(t,c);return{minPlatforms:d,maxPlatforms:Math.max(d,s),minPlatformLength:4,maxPlatformLength:12,minHorizontalGap:120,maxHorizontalGap:150,minVerticalGap:-120,maxVerticalGap:400,enemyProbability:i,crateProbability:r,barrelProbability:a,requiredCoins:100,targetEnemies:o,targetCrates:l,targetBarrels:h}}createPlayerStart(e){this.player=new N(this.scene,e.x,e.y-50-this.PLATFORM_DISPLAY_HEIGHT/2)}calculateNextPlatformPosition(e,t,s,i){let r=e.x,a=e.y,n=0,o=0;if(s){const e=s.getBounds(),l=32*t/2,h=1.2*i.maxHorizontalGap;n=this.prng.nextInt(i.minHorizontalGap,h+1),o=this.prng.nextInt(i.minVerticalGap,i.maxVerticalGap+1),Math.abs(o)<20&&(o=o>=0?20:-20,o=Phaser.Math.Clamp(o,i.minVerticalGap,i.maxVerticalGap)),r=e.right+n+l,a=s.y+o;const c=100,d=1/0;a=Phaser.Math.Clamp(a,c,d),o=a-s.y}else console.error("calculateNextPlatformPosition called without lastPlatform!");return{nextX:r,nextY:a,dX:n,dY:o}}createPlatform(e,t,s){const i=new U(this.scene,e.x,e.y,t,0===s?"start":s===t-1?"end":"middle");return this.platforms.push(i),i}createFinishPoint(e){if(!e)return;const t=e.getBounds(),s=t.right-40,i=t.top-45;new $(this.scene,s,i)}calculateOverallBounds(){if(0===this.platforms.length)return this.levelMinX=0,this.levelMaxX=1e3,this.levelLowestY=1/0,void console.warn("LevelGenerator: No platforms generated, using default bounds.");const e=this.platforms[0].getBounds();this.levelMinX=e.left,this.levelMaxX=e.right,this.levelLowestY=e.bottom;for(let t=1;t<this.platforms.length;t++){const e=this.platforms[t].getBounds();this.levelMinX=Math.min(this.levelMinX,e.left),this.levelMaxX=Math.max(this.levelMaxX,e.right),this.levelLowestY=Math.max(this.levelLowestY,e.bottom)}}getEnemies(){return this.enemies}getPlatforms(){return this.platforms}getCoins(){return this.coins}removeCoin(e){this.coins=this.coins.filter((t=>t!==e))}getCrates(){return this.crates}getBarrels(){return this.barrels}getOverallLevelBounds(){return{minX:this.levelMinX,maxX:this.levelMaxX,lowestY:this.levelLowestY}}}class oe extends i.GameObjects.TileSprite{constructor(e,s,i,r,a,n=.5){super(e,0,0,r,a,s,i),t(this,"customScrollFactorX"),this.customScrollFactorX=n,this.setOrigin(0,0),this.setScrollFactor(0,0),e.add.existing(this)}update(){this.tilePositionX=this.scene.cameras.main.scrollX*this.customScrollFactorX}}class le{constructor(e){t(this,"scene"),t(this,"backgroundLayer"),t(this,"middleLayer"),t(this,"foregroundLayer"),t(this,"levelWidth",0),t(this,"bgScrollFactorX"),t(this,"midScrollFactorX"),t(this,"fgScrollFactorX"),this.scene=e}initialize(e){this.levelWidth=Math.max(e,this.scene.scale.width),this.createLayers()}createLayers(){const e=this.scene.scale.height;this.bgScrollFactorX=.2,this.midScrollFactorX=1.5,this.fgScrollFactorX=2;const t=(t,s,i,r,a,n)=>{const o=this.scene.textures.getFrame(t,s);o||console.error(`Frame '${s}' not found in atlas '${t}'`);const l=o.height*a,h=e-l+r,c=new oe(this.scene,t,s,this.levelWidth,l,n);return c.y=h,c.setDepth(i),c};this.backgroundLayer=t(h,"bg/background.png",-3,-220,1,this.bgScrollFactorX),this.middleLayer=t(h,"bg/middle-ground.png",-2,-250,1,this.midScrollFactorX),this.foregroundLayer=t(h,"bg/foreground.png",3,-250,1,this.fgScrollFactorX)}update(){this.backgroundLayer&&this.middleLayer&&this.foregroundLayer&&(this.backgroundLayer.update(),this.middleLayer.update(),this.foregroundLayer.update())}}class he extends s.Scene{constructor(){super(n),t(this,"player"),t(this,"overlayButton"),t(this,"restartTriggered",!1),t(this,"physicsEnabled",!1),t(this,"gameState",m),t(this,"enemies",[]),t(this,"barrels",[]),t(this,"cameraManager"),t(this,"levelGenerator"),t(this,"parallaxManager"),t(this,"totalBarrelsGenerated",0),t(this,"culledBarrelsCount",0),t(this,"physicsDebugActive",!1),t(this,"debugGraphics"),t(this,"initialPhysicsDebugState",!1),t(this,"handleCollisionStart",(({pairs:e})=>{if(this.physicsEnabled)for(const{bodyA:t,bodyB:s}of e){if(this.checkFallSensorCollision(t,s))return;if(this.checkEnemyCollision(t,s))return;if(this.checkFinishCollision(t,s))return;if(this.checkCoinCollision(t,s))return;if(this.checkBarrelCollision(t,s))return}}))}init(e){this.initialPhysicsDebugState=e.physicsDebugWasActive??!1,console.log(`[Game Init] Received initial physics debug state: ${this.initialPhysicsDebugState}`)}create(){this.restartTriggered=!1,this.parallaxManager=new le(this),this.setupWorldBounds(),this.initGame(),this.showUIOverlay(m),this.debugGraphics&&this.debugGraphics.destroy(),this.debugGraphics=this.add.graphics().setAlpha(1).setDepth(9999),this.matter.world.debugGraphic=this.debugGraphics,this.matter.world.drawDebug=this.initialPhysicsDebugState,this.physicsDebugActive=this.initialPhysicsDebugState,this.debugGraphics.setVisible(this.initialPhysicsDebugState),console.log(`[Game Create] Set physics debug state based on init: ${this.physicsDebugActive}`),this.game.events.on("togglePhysicsDebug",this.togglePhysicsDebug,this)}setupWorldBounds(){this.matter.world.setBounds(0,0,d,u),this.matter.world.enabled=!1}initGame(){if(B=0,D=0,S=0,0===I()&&(S=1),this.enemies=[],this.barrels=[],this.generateLevelEntities(),this.setupCollisions(),!this.player)throw new Error("Player not created during level generation!");this.cameraManager=new A(this,this.player)}generateLevelEntities(){const e=I();this.levelGenerator=new ne(this,e),this.player=this.levelGenerator.generateLevel(),this.enemies=this.levelGenerator.getEnemies(),this.barrels=this.levelGenerator.getBarrels(),this.totalBarrelsGenerated=this.barrels.length;const t=this.levelGenerator.getOverallLevelBounds(),{minX:s,maxX:i,lowestY:r}=t,a=s===-1/0?0:s,n=i===1/0?a:i,o=Math.max(n-a,this.scale.width);this.parallaxManager&&this.parallaxManager.initialize(o);const l=o+1e3,h=a+(n-a)/2;this.createFallSensor(r,h,l)}showUIOverlay(e,t=!0){if(this.overlayButton&&(this.overlayButton.off("pointerup"),this.overlayButton.destroy(),this.overlayButton=void 0),e===p)return void(this.gameState=e);const s=this.game.canvas.width/2,i=this.game.canvas.height/2;let r,a;switch(e){case m:r="ui/start.png",a=()=>{var e;null==(e=this.overlayButton)||e.destroy(),this.overlayButton=void 0,this.startGame()};break;case g:r="ui/game-over.png",a=()=>{this.restartTriggered||this.restartLevel()};break;case f:r="ui/start.png",a=()=>{this.restartTriggered||this.restartLevel()};break;default:return}this.overlayButton=this.add.image(s,i,h,r).setOrigin(.5).setScrollFactor(0).setDepth(1e3).setInteractive({useHandCursor:!0}),t&&(this.overlayButton.setAlpha(0),this.tweens.add({targets:this.overlayButton,alpha:1,duration:400,ease:"Power2"})),this.overlayButton.on("pointerup",a),this.gameState=e}togglePhysicsDebug(){this.physicsDebugActive=!this.physicsDebugActive,console.log(`[Game] Toggling physics debug. Active: ${this.physicsDebugActive}`),this.matter.world.drawDebug=this.physicsDebugActive,this.debugGraphics||(console.warn("[Game] Debug graphics object not found during toggle."),this.debugGraphics=this.add.graphics().setAlpha(1).setDepth(9999),this.matter.world.debugGraphic=this.debugGraphics),console.log(`[Game] Matter world drawDebug set to: ${this.matter.world.drawDebug}`),this.debugGraphics.setVisible(this.physicsDebugActive),console.log(`[Game] Debug graphics visible: ${this.debugGraphics.visible}`)}startGame(){this.gameState=p,this.matter.world.enabled=!0,this.physicsEnabled=!0}createFallSensor(e,t,s){const i=e+500+50;this.matter.add.rectangle(t,i,s,100,{isSensor:!0,isStatic:!0,label:"fallSensor",collisionFilter:{group:0,category:16,mask:23}})}setupCollisions(){this.matter.world.on("collisionstart",this.handleCollisionStart)}checkFallSensorCollision(e,t){return!!(P(e)&&v(t)||P(t)&&v(e))&&(this.handleGameOver(),!0)}checkEnemyCollision(e,t){return!!(w(e)&&v(t)||w(t)&&v(e))&&(this.handleGameOver(),!0)}checkFinishCollision(e,t){return!!(x(e)&&v(t)||x(t)&&v(e))&&(x(e)?e.gameObject.activate():x(t)&&t.gameObject.activate(),this.handleLevelComplete(),!0)}checkCoinCollision(e,t){return b(e)&&v(t)?(this.collectCoin(e),!0):!(!b(t)||!v(e)||(this.collectCoin(t),0))}collectCoin(e){const t=e.gameObject;var s;t&&(this.levelGenerator.removeCoin(t),t.collect(),s=L()+1,B=s)}update(){var e,t;if(null==(e=this.parallaxManager)||e.update(),!this.physicsEnabled)return;null==(t=this.player)||t.update(),this.enemies.forEach((e=>e.update()));const i=this.cameras.main,r=new s.Geom.Rectangle(i.worldView.x-100,i.worldView.y-100,i.worldView.width+200,i.worldView.height+200);this.levelGenerator.getCoins().forEach((e=>{const t=s.Geom.Rectangle.Overlaps(r,e.getBounds());e.setVisible(t),e.setActive(t)})),this.enemies.forEach((e=>{const t=s.Geom.Rectangle.Overlaps(r,e.getBounds());e.setVisible(t),e.setActive(t)})),this.culledBarrelsCount=0,this.barrels.forEach((e=>{const t=s.Geom.Rectangle.Overlaps(r,e.getBounds());e.setVisible(t),e.setActive(t),t?e.update():this.culledBarrelsCount++}))}handleGameOver(){this.gameState===p&&(this.player.kill(),this.physicsEnabled=!1,this.enemies.forEach((e=>e.handleGameOver())),this.cameraManager.handleZoomIn(),this.showUIOverlay(g))}handleLevelComplete(){this.gameState===p&&(this.player.finishLevel(),((e=1)=>{S+=e})(1),this.enemies.forEach((e=>e.handleGameOver())),this.cameraManager.handleZoomIn(),this.showUIOverlay(f))}restartLevel(){if(this.restartTriggered)return;this.restartTriggered=!0;const e=this.physicsDebugActive;console.log(`[Game] Restarting level. Passing debug state: ${e}`),this.matter.world?this.matter.world.off("collisionstart",this.handleCollisionStart):console.warn("[Game] Matter world not found during restart cleanup."),this.game.events.off("togglePhysicsDebug",this.togglePhysicsDebug,this),this.scene.isActive(o)&&(console.log("[Game Restart] Stopping Debug UI scene."),this.scene.stop(o)),this.scene.restart({physicsDebugWasActive:e})}checkBarrelCollision(e,t){let s=null,i=null;if(v(e)&&C(t)?(s=e,i=t):v(t)&&C(e)&&(s=t,i=e),s&&i){const e=i.gameObject;if(e&&!this.player.isInBarrel&&!this.player.recentlyExitedBarrel)return console.log("[Game] Player collided with barrel",e),this.player.enterBarrel(e),!0}return!1}}class ce extends s.Scene{constructor(){super(a),t(this,"background"),t(this,"logo"),t(this,"playButton")}create(){const{width:e,height:t}=this.scale;let s;this.background=this.add.image(e/2,t/2,h,"ui/main-menu/background.png"),s=e/t>this.background.width/this.background.height?e/this.background.width:t/this.background.height,this.background.setScale(s).setScrollFactor(0),this.logo=this.add.image(e/2,.4*t,h,"ui/main-menu/title.png"),this.playButton=this.add.image(e/2,.6*t,h,"ui/main-menu/play-game.png").setInteractive({useHandCursor:!0}),this.playButton.on("pointerdown",(()=>{this.scene.start(n)}))}}class de extends s.Scene{constructor(){super(r)}init(){this.add.image(512,384,"background"),this.add.rectangle(512,384,468,32).setStrokeStyle(1,16777215);const e=this.add.rectangle(282,384,4,28,16777215);this.load.on("progress",(t=>{e.width=4+460*t}))}preload(){this.load.setPath("assets"),this.load.multiatlas(h,"assets.json"),this.load.json(c,"physics.json")}create(){this.setupAnimations(),this.scene.start(a)}setupAnimations(){E(this.game.anims,h,X),E(this.game.anims,h,W),E(this.game.anims,h,V),E(this.game.anims,h,R),E(this.game.anims,h,H)}}class ue{constructor(e,s,i){t(this,"scene"),t(this,"text"),t(this,"active",!1),this.scene=e,this.text=this.scene.add.text(s,i,"Debug Panel (Press Q)",{fontSize:"24px",color:"#ffffff",backgroundColor:"rgba(0,0,0,0.7)",padding:{x:8,y:5},fixedWidth:500}),this.text.setOrigin(1,0),this.text.setScrollFactor(0),this.text.setDepth(100),this.text.setVisible(this.active)}toggle(){this.active=!this.active,this.text.setVisible(this.active)}update(e){if(!this.active)return;let t="Debug Panel (Q)\n-----------------\n";const s=["PlayerPos","Platforms","Enemies","CulledEnemies","Coins","CulledCoins","Crates","Barrels","CulledBarrels"];for(const i of s)if(Object.prototype.hasOwnProperty.call(e,i)){const s=e[i];t+="PlayerPos"===i&&"object"==typeof s&&null!==s?`${i}: x=${Math.round(s.x)}, y=${Math.round(s.y)}\n`:"number"==typeof s?`${i}: ${s}\n`:`${i}: ${JSON.stringify(s)}\n`,delete e[i]}for(const i in e)if(Object.prototype.hasOwnProperty.call(e,i)){const s=e[i];t+=`${i}: ${JSON.stringify(s)}\n`}this.text.setText(t)}destroy(){this.text.destroy()}}class me{constructor(e){t(this,"scene"),t(this,"text"),this.scene=e,this.text=this.scene.add.text(16,16,"Coins: 0 / 0",{fontFamily:"Roboto",fontSize:"36px",color:"#ffffff",stroke:"#000000",strokeThickness:3}).setScrollFactor(0).setDepth(100)}update(){this.text.setText(`Coins: ${L()} / ${D}`)}destroy(){this.text.destroy()}}class pe{constructor(e){t(this,"scene"),t(this,"text"),this.scene=e,this.text=this.scene.add.text(16,70,"Level: 0",{fontFamily:"Roboto",fontSize:"36px",color:"#ffffff",stroke:"#000000",strokeThickness:3}).setScrollFactor(0).setDepth(100)}update(){this.text.setText("Level: "+I())}destroy(){this.text.destroy()}}class ge extends i.Scene{constructor(){super(o),t(this,"debugPanel"),t(this,"coinUI"),t(this,"levelUI")}create(){var e;console.log("DebugUIScene created"),this.debugPanel=new ue(this,this.scale.width-10,10),this.coinUI=new me(this),this.levelUI=new pe(this);const t=this.scene.get(n);t&&(t.events.on("updateDebugData",this.handleDebugDataUpdate,this),this.events.on(i.Scenes.Events.SHUTDOWN,(()=>{console.log("DebugUIScene shutting down, removing listener"),t.events.off("updateDebugData",this.handleDebugDataUpdate,this),this.levelUI.destroy(),this.coinUI.destroy()}))),null==(e=this.input.keyboard)||e.on("keydown-Q",(()=>{this.debugPanel.toggle(),this.game.events.emit("togglePhysicsDebug")}))}handleDebugDataUpdate(e){this.debugPanel.update(e)}update(){this.coinUI.update(),this.levelUI.update()}}const fe={type:Phaser.AUTO,width:1920,height:1080,parent:"game-container",backgroundColor:"#028af8",scale:{mode:Phaser.Scale.EXPAND,autoCenter:Phaser.Scale.CENTER_BOTH},physics:{default:"matter",matter:{gravity:{x:0,y:1},debug:{showAxes:!1,showAngleIndicator:!0,showBounds:!1,showCollisions:!0,showConvexHulls:!0,showInternalEdges:!1,showPositions:!0,showSeparation:!1,showVelocity:!0,renderFill:!0,renderLine:!0,lineColor:65280,fillColor:65280,fillOpacity:.1,lineOpacity:1,lineThickness:1,staticFillColor:255,staticLineColor:255}}},scene:[y,de,ce,he,ge]};new s.Game(fe);
